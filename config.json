{
  "name": "modassembly-web",
  "user": "lgaleana",
  "architecture": [
    {
      "design": {
        "type": "infrastructure",
        "name": "CloudRun",
        "namespace": "External",
        "config": {}
      },
      "file": null,
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "main",
        "namespace": "app",
        "dependencies": [
          "Other datamodels or functions"
        ],
        "purpose": "1) Calls load_dotenv().\n2) Initializes the FastAPI app.\n3) Adds CORSMiddleware with *.\n4) Adds all the application routers.\n5) Adds all the application models.\n6) Calls Base.metadata.create_all(engine).",
        "pypi_packages": [
          "fastapi==0.115.6",
          "mypy==1.15.0",
          "pydantic==2.10.4",
          "python-dotenv==1.0.1",
          "uvicorn==0.34.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/main.py",
        "content": "from dotenv import load_dotenv\nfrom fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\n\nload_dotenv()\n\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Models\n\nfrom app.modassembly.models.repository.Repository import Repository\nfrom app.modassembly.models.user.User import User\n\n# Endpoints\n\nfrom app.modassembly.users.endpoints.create_user_endpoint import router\napp.include_router(router)\nfrom app.modassembly.users.endpoints.login_user_endpoint import router\napp.include_router(router)\nfrom app.modassembly.repositories.endpoints.create_repository_endpoint import router\napp.include_router(router)\n\n# Database\n\nfrom app.modassembly.database.sql.get_sql_session import Base, engine\nBase.metadata.create_all(engine)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "infrastructure",
        "name": "CloudSQL",
        "namespace": "External",
        "config": {}
      },
      "file": null,
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "get_sql_session",
        "namespace": "app.modassembly.database.sql",
        "dependencies": [],
        "purpose": "1) Initializes Base, engine and SessionLocal. Uses the DB_URL environment variable.\n2) Yields a SessionLocal instance.",
        "pypi_packages": [
          "psycopg2-binary==2.9.10",
          "sqlalchemy==2.0.36"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/database/sql/get_sql_session.py",
        "content": "import os\nfrom typing import Iterator\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n\nBase = declarative_base()\nengine = create_engine(os.environ[\"DB_URL\"])\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\ndef get_sql_session() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "User",
        "namespace": "app.modassembly.models.user",
        "dependencies": [
          "app.modassembly.database.sql.get_sql_session"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the user."
          },
          {
            "name": "username",
            "purpose": "Unique username for the user."
          },
          {
            "name": "email",
            "purpose": "Email address for contact and login."
          },
          {
            "name": "hashed_password",
            "purpose": "Stores the hashed password."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the user was created."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/user/User.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime\nfrom app.modassembly.database.sql.get_sql_session import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, nullable=False, index=True)\n    email = Column(String, unique=True, nullable=False, index=True)\n    hashed_password = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "hash_password",
        "namespace": "app.modassembly.users.utils",
        "dependencies": [],
        "purpose": "Hashes a plaintext password using a secure hashing algorithm (e.g., bcrypt). Returns the hashed password. Keeps the implementation under 50 lines for clarity.",
        "pypi_packages": [
          "bcrypt==4.0.1"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/utils/hash_password.py",
        "content": "import os\nfrom typing import Final\nimport bcrypt\n\n# Retrieve the bcrypt salt rounds from environment variables, default to 12 if not set.\nBCRYPT_ROUNDS: Final[int] = int(os.environ.get(\"BCRYPT_ROUNDS\", 12))\n\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashes a plaintext password using bcrypt with the number of rounds defined by the environment variable BCRYPT_ROUNDS.\n    Returns the hashed password as a UTF-8 string.\n    \"\"\"\n    salt = bcrypt.gensalt(rounds=BCRYPT_ROUNDS)\n    hashed = bcrypt.hashpw(password.encode(\"utf-8\"), salt)\n    return hashed.decode(\"utf-8\")\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_user",
        "namespace": "app.modassembly.users.business",
        "dependencies": [
          "app.modassembly.users.utils.hash_password",
          "app.modassembly.database.sql.get_sql_session",
          "app.modassembly.models.user.User"
        ],
        "purpose": "Creates a new user by validating input, calling hash_password to secure the password, and storing the user in the database using get_sql_session. It ensures data integrity and handles errors.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/business/create_user.py",
        "content": "from datetime import datetime\nfrom typing import Iterator\n\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.users.utils.hash_password import hash_password\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\n\ndef create_user(username: str, email: str, password: str) -> User:\n    \"\"\"\n    Creates a new user by validating input, calling hash_password to secure the password,\n    and storing the user in the database using get_sql_session.\n    \"\"\"\n    hashed = hash_password(password)\n    new_user = User(\n        username=username,\n        email=email,\n        hashed_password=hashed,\n        created_at=datetime.utcnow()\n    )\n\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n\n    return new_user\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_user_endpoint",
        "namespace": "app.modassembly.users.endpoints",
        "dependencies": [
          "app.modassembly.users.business.create_user",
          "app.modassembly.models.user.User"
        ],
        "purpose": "FastAPI endpoint that receives user creation requests, extracts the payload, and calls create_user business logic. Returns appropriate HTTP responses.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/users/endpoints/create_user_endpoint.py",
        "content": "from fastapi import APIRouter, HTTPException, status\nfrom pydantic import BaseModel, EmailStr\nfrom app.modassembly.users.business.create_user import create_user\nfrom app.modassembly.models.user.User import User  # type: ignore\n\nrouter = APIRouter()\n\nclass CreateUserPayload(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass UserResponse(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    created_at: str\n\n@router.post(\n    \"/users\",\n    response_model=UserResponse,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create a new user\",\n    description=\"Endpoint to create a new user. Expects a JSON payload with username, email, and password.\"\n)\ndef create_user_endpoint(payload: CreateUserPayload) -> UserResponse:\n    \"\"\"\n    FastAPI endpoint that receives user creation requests, extracts the payload,\n    and calls create_user business logic. Returns appropriate HTTP responses.\n    \"\"\"\n    try:\n        user: User = create_user(payload.username, payload.email, payload.password)\n    except Exception as e:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=str(e))\n    \n    return UserResponse(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        created_at=user.created_at.isoformat()\n    )\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "verify_password",
        "namespace": "app.modassembly.users.utils",
        "dependencies": [],
        "purpose": "Verifies a plaintext password against a hashed password using bcrypt. Returns True if the credentials match, else False. Keeps the implementation clear and under 50 lines.",
        "pypi_packages": [
          "bcrypt==4.0.1"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/utils/verify_password.py",
        "content": "import bcrypt\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return bcrypt.checkpw(plain_password.encode(\"utf-8\"), hashed_password.encode(\"utf-8\"))\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "login_user",
        "namespace": "app.modassembly.users.business",
        "dependencies": [
          "app.modassembly.users.utils.verify_password",
          "app.modassembly.database.sql.get_sql_session",
          "app.modassembly.models.user.User"
        ],
        "purpose": "Logs in a user by retrieving the user record using get_sql_session, comparing the provided password with the stored hashed password using verify_password, and returning a token or error accordingly.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/business/login_user.py",
        "content": "from typing import Any\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.users.utils.verify_password import verify_password\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\n\ndef login_user(email: str, plain_password: str) -> str:\n    \"\"\"\n    Logs in a user by querying the database for a user with the given email,\n    verifying the provided plaintext password against the stored hashed password,\n    and returning a token string on success. Raises a ValueError if the user is not found\n    or the password is incorrect.\n    \"\"\"\n    # Retrieve a database session using get_sql_session generator.\n    for db in get_sql_session():\n        user: Any = db.query(User).filter(User.email == email).first()\n        if user is None:\n            raise ValueError(\"User not found\")\n        if not verify_password(plain_password, user.hashed_password):\n            raise ValueError(\"Incorrect password\")\n        # A simple token is generated by combining a constant secret from environment and user id.\n        # In a production environment, use secure token generation (e.g., JWT).\n        from os import environ\n        secret_key: str = environ[\"SECRET_KEY\"]\n        token: str = f\"{secret_key}-{user.id}\"\n        return token\n\n    # This line should theoretically never be reached.\n    raise RuntimeError(\"Database session could not be established\")\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "login_user_endpoint",
        "namespace": "app.modassembly.users.endpoints",
        "dependencies": [
          "app.modassembly.users.business.login_user"
        ],
        "purpose": "FastAPI endpoint that receives login requests, validates the input payload, calls login_user for authentication, and returns an appropriate HTTP response with authentication token or error message.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/users/endpoints/login_user_endpoint.py",
        "content": "from fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\nfrom app.modassembly.users.business.login_user import login_user\n\nrouter = APIRouter()\n\nclass LoginRequest(BaseModel):\n    email: str\n    password: str\n\nclass LoginResponse(BaseModel):\n    token: str\n\n@router.post(\n    \"/login\",\n    response_model=LoginResponse,\n    summary=\"User Login\",\n    description=\"Endpoint to log in a user by validating the input payload and returning an authentication token.\"\n)\ndef login_user_endpoint(payload: LoginRequest) -> LoginResponse:\n    \"\"\"\n    FastAPI endpoint that receives login requests, validates the input payload using pydantic,\n    calls the business logic function login_user for authentication, and returns an authentication\n    token if login is successful. Raises HTTPException with a 401 status code if authentication fails.\n    \"\"\"\n    try:\n        token: str = login_user(email=payload.email, plain_password=payload.password)\n        return LoginResponse(token=token)\n    except ValueError as error:\n        raise HTTPException(status_code=401, detail=str(error))\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "Repository",
        "namespace": "app.modassembly.models.repository",
        "dependencies": [
          "app.modassembly.database.sql.get_sql_session",
          "app.modassembly.models.user.User"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the repository."
          },
          {
            "name": "name",
            "purpose": "Name of the repository."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the repository was created."
          },
          {
            "name": "user_id",
            "purpose": "Foreign key to the User who owns this repository."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/repository/Repository.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey\nfrom app.modassembly.database.sql.get_sql_session import Base\nfrom app.modassembly.models.user.User import User  # Ensure User model is imported for reference\n\nclass Repository(Base):\n    __tablename__ = \"repositories\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, nullable=False, index=True)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    user_id = Column(Integer, ForeignKey(User.id), nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_repository",
        "namespace": "app.modassembly.repositories.business",
        "dependencies": [
          "app.modassembly.github.business.create_github_repository",
          "app.modassembly.database.sql.get_sql_session",
          "app.modassembly.models.repository.Repository",
          "app.modassembly.models.user.User"
        ],
        "purpose": "Creates a new repository for a given user. Validates input and ensures the user exists, then constructs a repository name as '{user_name}_{repo_name}', checks that it doesn't already exist in the GitHub 'Modular-Asembly' organization, and if not, creates it via the GitHub API by calling create_github_repository. Finally, it saves the repository in the local database.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/repositories/business/create_repository.py",
        "content": "from datetime import datetime\nfrom typing import Iterator\n\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.models.repository.Repository import Repository\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.github.business.create_github_repository import create_github_repository\n\ndef create_repository(user_id: int, repo_name: str) -> Repository:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    \n    user: User | None = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise ValueError(\"User not found\")\n    \n    full_repo_name: str = f\"{user.username}_{repo_name}\"\n    \n    # Create the GitHub repository (this will raise if exists)\n    github_url: str = create_github_repository(user.username, repo_name)\n    \n    new_repository: Repository = Repository(\n        name=full_repo_name,\n        created_at=datetime.utcnow(),\n        user_id=user.id\n    )\n    db.add(new_repository)\n    db.commit()\n    db.refresh(new_repository)\n    \n    # Close the database session\n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n    \n    return new_repository\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_repository_endpoint",
        "namespace": "app.modassembly.repositories.endpoints",
        "dependencies": [
          "app.modassembly.repositories.business.create_repository",
          "app.modassembly.models.repository.Repository"
        ],
        "purpose": "FastAPI endpoint that receives repository creation requests, validates the payload, calls create_repository business logic, and returns an appropriate HTTP response.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/repositories/endpoints/create_repository_endpoint.py",
        "content": "from fastapi import APIRouter, status\nfrom pydantic import BaseModel\nfrom app.modassembly.repositories.business.create_repository import create_repository\nfrom app.modassembly.models.repository.Repository import Repository\n\nrouter = APIRouter()\n\nclass CreateRepositoryPayload(BaseModel):\n    user_id: int\n    repo_name: str\n\nclass RepositoryResponse(BaseModel):\n    id: int\n    name: str\n    created_at: str\n    user_id: int\n\n@router.post(\n    \"/repositories\",\n    response_model=RepositoryResponse,\n    status_code=status.HTTP_201_CREATED,\n    summary=\"Create Repository\",\n    description=(\n        \"Creates a new repository for the given user. Validates the payload, \"\n        \"ensures the user exists, constructs the repository name, checks that it \"\n        \"does not already exist in the GitHub 'Modular-Asembly' organization, and if \"\n        \"not, creates it via the GitHub API. The repository is then saved in the local \"\n        \"database and details are returned.\"\n    )\n)\ndef create_repository_endpoint(payload: CreateRepositoryPayload) -> RepositoryResponse:\n    \"\"\"\n    FastAPI endpoint to create a new repository.\n\n    Parameters:\n    - payload: CreateRepositoryPayload\n        - user_id: The ID of the user who owns the repository.\n        - repo_name: The desired name of the repository.\n\n    Returns:\n    - RepositoryResponse containing the repository id, name, created_at timestamp, and user_id.\n    \"\"\"\n    repository: Repository = create_repository(payload.user_id, payload.repo_name)\n    return RepositoryResponse(\n        id=repository.id,\n        name=repository.name,\n        created_at=repository.created_at.isoformat(),\n        user_id=repository.user_id\n    )\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "check_github_repo_exists",
        "namespace": "app.modassembly.github.utils",
        "dependencies": [],
        "purpose": "Checks if a repository exists in the GitHub organization by calling the GitHub API. It constructs the repository name as '{user_name}_{repo_name}' and returns True if it exists, otherwise False. Utilizes 'requests' for the HTTP calls.",
        "pypi_packages": [
          "requests==2.31.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/github/utils/check_github_repo_exists.py",
        "content": "import os\nimport requests\nfrom typing import Final\n\ndef check_github_repo_exists(user_name: str, repo_name: str) -> bool:\n    github_org: Final[str] = os.environ[\"GITHUB_ORG\"]\n    token: Final[str] = os.environ[\"GITHUB_TOKEN\"]\n    repo_full_name: str = f\"{user_name}_{repo_name}\"\n    url: str = f\"https://api.github.com/repos/{github_org}/{repo_full_name}\"\n    headers: dict[str, str] = {\"Authorization\": f\"token {token}\"}\n    response: requests.Response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return True\n    if response.status_code == 404:\n        return False\n    response.raise_for_status()\n    return False  # This line is unreachable, but satisfies mypy.\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_github_repository",
        "namespace": "app.modassembly.github.business",
        "dependencies": [
          "app.modassembly.github.utils.check_github_repo_exists"
        ],
        "purpose": "Creates a new repository in the GitHub organization 'Modular-Asembly'. It retrieves the authentication token from the environment variable GITHUB_TOKEN, then checks that the repository (named '{user_name}_{repo_name}') does not exist by calling check_github_repo_exists. If the repository does not exist, it creates it using the GitHub API. Returns the GitHub URL of the new repository.",
        "pypi_packages": [
          "requests==2.31.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/github/business/create_github_repository.py",
        "content": "import os\nimport requests\nfrom typing import Final\n\nfrom app.modassembly.github.utils.check_github_repo_exists import check_github_repo_exists\n\ndef create_github_repository(user_name: str, repo_name: str) -> str:\n    github_org: Final[str] = os.environ[\"GITHUB_ORG\"]\n    token: Final[str] = os.environ[\"GITHUB_TOKEN\"]\n    repo_full_name: str = f\"{user_name}_{repo_name}\"\n    \n    # Check if repository already exists\n    if check_github_repo_exists(user_name, repo_name):\n        raise ValueError(f\"Repository {repo_full_name} already exists in organization {github_org}\")\n    \n    url: str = f\"https://api.github.com/orgs/{github_org}/repos\"\n    headers: dict[str, str] = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github+json\"\n    }\n    payload: dict[str, object] = {\n        \"name\": repo_full_name,\n        \"private\": False\n    }\n    \n    response: requests.Response = requests.post(url, json=payload, headers=headers)\n    response.raise_for_status()\n    repo_data: dict[str, object] = response.json()\n    github_url: str = repo_data[\"html_url\"]  # type: ignore\n    return github_url\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    }
  ],
  "github": "https://github.com/Modular-Asembly/lgaleana_modassembly-web"
}