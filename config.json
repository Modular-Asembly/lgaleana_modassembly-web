{
  "name": "modassembly-web",
  "user": "lgaleana",
  "architecture": [
    {
      "design": {
        "type": "infrastructure",
        "name": "CloudRun",
        "namespace": "External",
        "config": {}
      },
      "file": null,
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "main",
        "namespace": "app",
        "dependencies": [
          "Other datamodels or functions"
        ],
        "purpose": "1) Calls load_dotenv().\n2) Initializes the FastAPI app.\n3) Adds CORSMiddleware with *.\n4) Adds all the application routers.\n5) Adds all the application models.\n6) Calls Base.metadata.create_all(engine).",
        "pypi_packages": [
          "fastapi==0.115.6",
          "mypy==1.15.0",
          "pydantic==2.10.4",
          "python-dotenv==1.0.1",
          "uvicorn==0.34.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/main.py",
        "content": "from dotenv import load_dotenv\nfrom fastapi import FastAPI\nfrom starlette.middleware.cors import CORSMiddleware\n\n\nload_dotenv()\n\n\napp = FastAPI()\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\n# Models\n\nfrom app.modassembly.models.repository.Repository import Repository\nfrom app.modassembly.models.message.Message import Message\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.models.conversation.Conversation import Conversation\n\n# Endpoints\n\nfrom app.modassembly.users.endpoints.create_user_endpoint import router\napp.include_router(router)\nfrom app.modassembly.users.endpoints.login_user_endpoint import router\napp.include_router(router)\nfrom app.modassembly.repositories.endpoints.create_repository_endpoint import router\napp.include_router(router)\nfrom app.modassembly.repositories.endpoints.delete_repository_endpoint import router\napp.include_router(router)\nfrom app.modassembly.conversations.endpoints.get_conversation_endpoint import router\napp.include_router(router)\n\n# Database\n\nfrom app.modassembly.database.sql.get_sql_session import Base, engine\nBase.metadata.create_all(engine)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "infrastructure",
        "name": "CloudSQL",
        "namespace": "External",
        "config": {}
      },
      "file": null,
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "get_sql_session",
        "namespace": "app.modassembly.database.sql",
        "dependencies": [],
        "purpose": "1) Initializes Base, engine and SessionLocal. Uses the DB_URL environment variable.\n2) Yields a SessionLocal instance.",
        "pypi_packages": [
          "psycopg2-binary==2.9.10",
          "sqlalchemy==2.0.36"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/database/sql/get_sql_session.py",
        "content": "import os\nfrom typing import Iterator\n\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker\n\n\nBase = declarative_base()\nengine = create_engine(os.environ[\"DB_URL\"])\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n\ndef get_sql_session() -> Iterator[Session]:\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "User",
        "namespace": "app.modassembly.models.user",
        "dependencies": [
          "app.modassembly.database.sql.get_sql_session"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the user."
          },
          {
            "name": "username",
            "purpose": "Unique username for the user."
          },
          {
            "name": "email",
            "purpose": "Email address for contact and login."
          },
          {
            "name": "hashed_password",
            "purpose": "Stores the hashed password."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the user was created."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/user/User.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime\nfrom app.modassembly.database.sql.get_sql_session import Base\n\nclass User(Base):\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, nullable=False, index=True)\n    email = Column(String, unique=True, nullable=False, index=True)\n    hashed_password = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "hash_password",
        "namespace": "app.modassembly.users.utils",
        "dependencies": [],
        "purpose": "Hashes a plaintext password using a secure hashing algorithm (e.g., bcrypt). Returns the hashed password. Keeps the implementation under 50 lines for clarity.",
        "pypi_packages": [
          "bcrypt==4.0.1"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/utils/hash_password.py",
        "content": "import os\nfrom typing import Final\nimport bcrypt\n\n# Retrieve the bcrypt salt rounds from environment variables, default to 12 if not set.\nBCRYPT_ROUNDS: Final[int] = int(os.environ.get(\"BCRYPT_ROUNDS\", 12))\n\ndef hash_password(password: str) -> str:\n    \"\"\"\n    Hashes a plaintext password using bcrypt with the number of rounds defined by the environment variable BCRYPT_ROUNDS.\n    Returns the hashed password as a UTF-8 string.\n    \"\"\"\n    salt = bcrypt.gensalt(rounds=BCRYPT_ROUNDS)\n    hashed = bcrypt.hashpw(password.encode(\"utf-8\"), salt)\n    return hashed.decode(\"utf-8\")\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_user",
        "namespace": "app.modassembly.users.business",
        "dependencies": [
          "app.modassembly.database.sql.get_sql_session",
          "app.modassembly.models.user.User",
          "app.modassembly.users.utils.hash_password"
        ],
        "purpose": "Creates a new user by validating input, calling hash_password to secure the password, and storing the user in the database using get_sql_session. It ensures data integrity and handles errors.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/business/create_user.py",
        "content": "from datetime import datetime\nfrom typing import Iterator\n\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.users.utils.hash_password import hash_password\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\n\ndef create_user(username: str, email: str, password: str) -> User:\n    \"\"\"\n    Creates a new user by validating input, calling hash_password to secure the password,\n    and storing the user in the database using get_sql_session.\n    \"\"\"\n    hashed = hash_password(password)\n    new_user = User(\n        username=username,\n        email=email,\n        hashed_password=hashed,\n        created_at=datetime.utcnow()\n    )\n\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n\n    return new_user\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_user_endpoint",
        "namespace": "app.modassembly.users.endpoints",
        "dependencies": [
          "app.modassembly.users.business.create_user",
          "app.modassembly.models.user.User",
          "app.modassembly.auth.authenticate"
        ],
        "purpose": "FastAPI endpoint that receives user creation requests, authenticates the caller using the authenticate function, extracts the payload, and calls create_user business logic. Returns appropriate HTTP responses.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/users/endpoints/create_user_endpoint.py",
        "content": "from fastapi import APIRouter, Header, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom app.modassembly.auth.authenticate import authenticate\nfrom app.modassembly.users.business.create_user import create_user\nfrom app.modassembly.models.user.User import User\nfrom datetime import datetime\n\nrouter = APIRouter(\n    prefix=\"/users\",\n    tags=[\"Users\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\nclass CreateUserInput(BaseModel):\n    username: str\n    email: EmailStr\n    password: str\n\nclass CreateUserOutput(BaseModel):\n    id: int\n    username: str\n    email: EmailStr\n    created_at: datetime\n\n@router.post(\n    \"/create\",\n    response_model=CreateUserOutput,\n    summary=\"Create a new user\",\n    description=(\n        \"Receives a user creation request along with an authentication token. \"\n        \"It authenticates the caller using the JWT token from the Authorization header, \"\n        \"extracts the payload, and calls the create_user business logic to create a new user. \"\n        \"Returns the created user details.\"\n    ),\n)\ndef create_user_endpoint(\n    payload: CreateUserInput, authorization: str = Header(...)\n) -> CreateUserOutput:\n    \"\"\"\n    Endpoint to create a new user.\n    \n    Expects:\n    - **Authorization** header with a Bearer token.\n    - JSON payload with `username`, `email`, and `password`.\n    \n    Returns a JSON object with user details:\n    - **id**: User's unique identifier.\n    - **username**: The username provided.\n    - **email**: The email address provided.\n    - **created_at**: Timestamp of user creation.\n    \"\"\"\n    # Extract the token from the \"Bearer <token>\" format.\n    try:\n        scheme, token = authorization.split()\n    except ValueError:\n        raise HTTPException(status_code=400, detail=\"Invalid authorization header format\")\n    if scheme.lower() != \"bearer\":\n        raise HTTPException(status_code=400, detail=\"Authorization scheme must be Bearer\")\n    \n    # Authenticate the caller. If the token is invalid, an exception will be raised.\n    _ = authenticate(token)\n    \n    # Create the user using business logic.\n    user: User = create_user(\n        username=payload.username,\n        email=payload.email,\n        password=payload.password\n    )\n    \n    return CreateUserOutput(\n        id=user.id,\n        username=user.username,\n        email=user.email,\n        created_at=user.created_at\n    )\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "verify_password",
        "namespace": "app.modassembly.users.utils",
        "dependencies": [],
        "purpose": "Verifies a plaintext password against a hashed password using bcrypt. Returns True if the credentials match, else False. Keeps the implementation clear and under 50 lines.",
        "pypi_packages": [
          "bcrypt==4.0.1"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/utils/verify_password.py",
        "content": "import bcrypt\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return bcrypt.checkpw(plain_password.encode(\"utf-8\"), hashed_password.encode(\"utf-8\"))\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "login_user",
        "namespace": "app.modassembly.users.business",
        "dependencies": [
          "app.modassembly.users.utils.verify_password",
          "app.modassembly.models.user.User",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "Logs in a user by retrieving the user record using get_sql_session, comparing the provided password with the stored hashed password using verify_password, and returning a token or error accordingly.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/users/business/login_user.py",
        "content": "from typing import Any\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.users.utils.verify_password import verify_password\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\n\ndef login_user(email: str, plain_password: str) -> str:\n    \"\"\"\n    Logs in a user by querying the database for a user with the given email,\n    verifying the provided plaintext password against the stored hashed password,\n    and returning a token string on success. Raises a ValueError if the user is not found\n    or the password is incorrect.\n    \"\"\"\n    # Retrieve a database session using get_sql_session generator.\n    for db in get_sql_session():\n        user: Any = db.query(User).filter(User.email == email).first()\n        if user is None:\n            raise ValueError(\"User not found\")\n        if not verify_password(plain_password, user.hashed_password):\n            raise ValueError(\"Incorrect password\")\n        # A simple token is generated by combining a constant secret from environment and user id.\n        # In a production environment, use secure token generation (e.g., JWT).\n        from os import environ\n        secret_key: str = environ[\"SECRET_KEY\"]\n        token: str = f\"{secret_key}-{user.id}\"\n        return token\n\n    # This line should theoretically never be reached.\n    raise RuntimeError(\"Database session could not be established\")\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "login_user_endpoint",
        "namespace": "app.modassembly.users.endpoints",
        "dependencies": [
          "app.modassembly.users.business.login_user"
        ],
        "purpose": "FastAPI endpoint that receives login requests, validates the input payload, calls login_user for authentication, and returns an HTTP response with an authentication token or error message. This endpoint does not require prior authentication.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/users/endpoints/login_user_endpoint.py",
        "content": "from fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel, EmailStr\nfrom app.modassembly.users.business.login_user import login_user\n\nrouter = APIRouter(\n    prefix=\"/login\",\n    tags=[\"Authentication\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\nclass LoginUserInput(BaseModel):\n    email: EmailStr\n    plain_password: str\n\nclass LoginUserOutput(BaseModel):\n    token: str\n\n@router.post(\n    \"\",\n    response_model=LoginUserOutput,\n    summary=\"User Login\",\n    description=(\n        \"Receives login requests. Validates the input payload and calls the login_user \"\n        \"business logic for authentication. Returns an authentication token if the credentials \"\n        \"are valid, otherwise an HTTP error is raised.\"\n    ),\n)\ndef login_user_endpoint(payload: LoginUserInput) -> LoginUserOutput:\n    \"\"\"\n    Endpoint to log in a user.\n    \n    - **email**: user's email address.\n    - **plain_password**: user's plaintext password.\n    \n    Returns a JSON object with a field `token` containing the authentication token.\n    \"\"\"\n    token = login_user(email=payload.email, plain_password=payload.plain_password)\n    return LoginUserOutput(token=token)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "Repository",
        "namespace": "app.modassembly.models.repository",
        "dependencies": [
          "app.modassembly.models.user.User",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the repository."
          },
          {
            "name": "name",
            "purpose": "Name of the repository."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the repository was created."
          },
          {
            "name": "user_id",
            "purpose": "Foreign key to the User who owns this repository."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/repository/Repository.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey\nfrom app.modassembly.database.sql.get_sql_session import Base\nfrom app.modassembly.models.user.User import User  # Ensure User model is imported for reference\n\nclass Repository(Base):\n    __tablename__ = \"repositories\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, unique=True, nullable=False, index=True)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n    user_id = Column(Integer, ForeignKey(User.id), nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_repository",
        "namespace": "app.modassembly.repositories.business",
        "dependencies": [
          "app.modassembly.models.user.User",
          "app.modassembly.conversations.business.create_conversations_for_repository",
          "app.modassembly.models.repository.Repository",
          "app.modassembly.github.business.create_github_repository",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "Creates a new repository for a given user. Validates input and ensures the user exists, then constructs a repository name as '{user_name}_{repo_name}', checks that it doesn't already exist in the GitHub 'Modular-Asembly' organization, and if not, creates it via the GitHub API by calling create_github_repository. After saving the repository in the local database, it calls create_conversations_for_repository to add two default conversations ('brainstorm' and 'architecture').",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/repositories/business/create_repository.py",
        "content": "from typing import Iterator\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.github.business.create_github_repository import create_github_repository\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.models.repository.Repository import Repository\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.conversations.business.create_conversations_for_repository import create_conversations_for_repository\n\ndef create_repository(user_id: int, repo_name: str) -> Repository:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    \n    # Verify that the user exists\n    user: User | None = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise ValueError(f\"User with id {user_id} not found\")\n    \n    # Construct repository name using user's username and the provided repo_name\n    constructed_repo_name: str = f\"{user.username}_{repo_name}\"\n    \n    # Check that the repository doesn't already exist in GitHub and create it via GitHub API.\n    # If it already exists, create_github_repository will raise a ValueError.\n    _ = create_github_repository(user.username, repo_name)\n    \n    # Create a new Repository record in the local database\n    new_repository = Repository(\n        name=constructed_repo_name,\n        user_id=user.id\n    )\n    db.add(new_repository)\n    db.commit()\n    db.refresh(new_repository)\n    \n    # Create default conversations for the repository\n    create_conversations_for_repository(new_repository.id)\n    \n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n    \n    return new_repository\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_repository_endpoint",
        "namespace": "app.modassembly.repositories.endpoints",
        "dependencies": [
          "app.modassembly.models.repository.Repository",
          "app.modassembly.auth.authenticate",
          "app.modassembly.repositories.business.create_repository"
        ],
        "purpose": "FastAPI endpoint that receives repository creation requests, authenticates the user using the authenticate function, validates the payload, calls create_repository business logic, and returns an appropriate HTTP response.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/repositories/endpoints/create_repository_endpoint.py",
        "content": "from fastapi import APIRouter, Header, HTTPException\nfrom pydantic import BaseModel\nfrom app.modassembly.auth.authenticate import authenticate\nfrom app.modassembly.repositories.business.create_repository import create_repository\nfrom app.modassembly.models.repository.Repository import Repository\n\nrouter = APIRouter(\n    prefix=\"/repositories\",\n    tags=[\"Repositories\"],\n    responses={401: {\"description\": \"Unauthorized\"}, 404: {\"description\": \"Not found\"}},\n)\n\nclass CreateRepositoryInput(BaseModel):\n    repo_name: str\n\nclass CreateRepositoryOutput(BaseModel):\n    id: int\n    name: str\n    user_id: int\n\n@router.post(\n    \"\",\n    response_model=CreateRepositoryOutput,\n    summary=\"Create Repository\",\n    description=(\n        \"Receives repository creation requests, authenticates the user using a Bearer token \"\n        \"provided in the Authorization header, validates the payload, calls the create_repository \"\n        \"business logic, and returns the created repository details.\"\n    ),\n)\ndef create_repository_endpoint(\n    payload: CreateRepositoryInput,\n    authorization: str = Header(..., description=\"Bearer token for authentication\"),\n) -> CreateRepositoryOutput:\n    \"\"\"\n    Endpoint to create a new repository for the authenticated user.\n    \n    - **repo_name**: Name of the repository to be created.\n    \n    The Authorization header must be in the format: 'Bearer <token>'.\n    \n    Returns a JSON object with the repository id, name, and associated user_id.\n    \"\"\"\n    if not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Invalid Authorization header format\")\n    token = authorization[7:]  # Remove 'Bearer ' prefix\n    auth_payload = authenticate(token)\n    \n    # Expecting the authentication payload to include the user_id.\n    user_id: int = auth_payload[\"user_id\"]\n    \n    repository: Repository = create_repository(user_id=user_id, repo_name=payload.repo_name)\n    \n    return CreateRepositoryOutput(\n        id=repository.id,\n        name=repository.name,\n        user_id=repository.user_id,\n    )\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "check_github_repo_exists",
        "namespace": "app.modassembly.github.utils",
        "dependencies": [],
        "purpose": "Checks if a repository exists in the GitHub organization by calling the GitHub API. It constructs the repository name as '{user_name}_{repo_name}' and returns True if it exists, otherwise False. Utilizes 'requests' for the HTTP calls.",
        "pypi_packages": [
          "requests==2.31.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/github/utils/check_github_repo_exists.py",
        "content": "import os\nimport requests\nfrom typing import Final\n\ndef check_github_repo_exists(user_name: str, repo_name: str) -> bool:\n    github_org: Final[str] = os.environ[\"GITHUB_ORG\"]\n    token: Final[str] = os.environ[\"GITHUB_TOKEN\"]\n    repo_full_name: str = f\"{user_name}_{repo_name}\"\n    url: str = f\"https://api.github.com/repos/{github_org}/{repo_full_name}\"\n    headers: dict[str, str] = {\"Authorization\": f\"token {token}\"}\n    response: requests.Response = requests.get(url, headers=headers)\n    if response.status_code == 200:\n        return True\n    if response.status_code == 404:\n        return False\n    response.raise_for_status()\n    return False  # This line is unreachable, but satisfies mypy.\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_github_repository",
        "namespace": "app.modassembly.github.business",
        "dependencies": [
          "app.modassembly.github.utils.check_github_repo_exists"
        ],
        "purpose": "Creates a new repository in the GitHub organization 'Modular-Asembly'. It retrieves the authentication token from the environment variable GITHUB_TOKEN, then checks that the repository (named '{user_name}_{repo_name}') does not exist by calling check_github_repo_exists. If the repository does not exist, it creates it using the GitHub API. Returns the GitHub URL of the new repository.",
        "pypi_packages": [
          "requests==2.31.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/github/business/create_github_repository.py",
        "content": "import os\nimport requests\nfrom typing import Final\n\nfrom app.modassembly.github.utils.check_github_repo_exists import check_github_repo_exists\n\ndef create_github_repository(user_name: str, repo_name: str) -> str:\n    github_org: Final[str] = os.environ[\"GITHUB_ORG\"]\n    token: Final[str] = os.environ[\"GITHUB_TOKEN\"]\n    repo_full_name: str = f\"{user_name}_{repo_name}\"\n    \n    # Check if repository already exists\n    if check_github_repo_exists(user_name, repo_name):\n        raise ValueError(f\"Repository {repo_full_name} already exists in organization {github_org}\")\n    \n    url: str = f\"https://api.github.com/orgs/{github_org}/repos\"\n    headers: dict[str, str] = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github+json\"\n    }\n    payload: dict[str, object] = {\n        \"name\": repo_full_name,\n        \"private\": False\n    }\n    \n    response: requests.Response = requests.post(url, json=payload, headers=headers)\n    response.raise_for_status()\n    repo_data: dict[str, object] = response.json()\n    github_url: str = repo_data[\"html_url\"]  # type: ignore\n    return github_url\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "delete_github_repository",
        "namespace": "app.modassembly.github.business",
        "dependencies": [
          "app.modassembly.github.utils.check_github_repo_exists"
        ],
        "purpose": "Deletes a repository from the GitHub organization 'Modular-Asembly'. It retrieves the authentication token from the environment variable GITHUB_TOKEN, constructs the repository name as '{user_name}_{repo_name}', and calls the GitHub API to delete the repository if it exists. Returns status of deletion.",
        "pypi_packages": [
          "requests==2.31.0"
        ],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/github/business/delete_github_repository.py",
        "content": "import os\nimport requests\nfrom typing import Final\n\nfrom app.modassembly.github.utils.check_github_repo_exists import check_github_repo_exists\n\ndef delete_github_repository(user_name: str, repo_name: str) -> str:\n    \"\"\"\n    Deletes a repository from the GitHub organization 'Modular-Asembly'. \n    It retrieves the authentication token from the environment variable GITHUB_TOKEN, \n    constructs the repository name as '{user_name}_{repo_name}', and calls the GitHub API \n    to delete the repository if it exists.\n    \n    Parameters:\n        user_name (str): The GitHub username.\n        repo_name (str): The repository name (without prefix).\n    \n    Returns:\n        str: A message indicating successful deletion.\n    \n    Raises:\n        ValueError: If the repository does not exist in the GitHub organization.\n        requests.HTTPError: For any HTTP-related error returned by the GitHub API.\n        KeyError: If required environment variables are missing.\n    \"\"\"\n    github_org: Final[str] = os.environ[\"GITHUB_ORG\"]\n    token: Final[str] = os.environ[\"GITHUB_TOKEN\"]\n    repo_full_name: str = f\"{user_name}_{repo_name}\"\n    \n    if not check_github_repo_exists(user_name, repo_name):\n        raise ValueError(\n            f\"Repository {repo_full_name} does not exist in organization {github_org}\"\n        )\n    \n    url: str = f\"https://api.github.com/repos/{github_org}/{repo_full_name}\"\n    headers: dict[str, str] = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github+json\"\n    }\n    \n    response: requests.Response = requests.delete(url, headers=headers)\n    response.raise_for_status()\n    \n    return \"Repository deleted successfully\"\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "delete_repository",
        "namespace": "app.modassembly.repositories.business",
        "dependencies": [
          "app.modassembly.github.business.delete_github_repository",
          "app.modassembly.models.user.User",
          "app.modassembly.models.repository.Repository",
          "app.modassembly.conversations.business.delete_conversations_for_repository",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "Deletes a repository for a given user. Validates input, checks if the repository exists in the local database, first calls delete_github_repository to remove it from GitHub, then calls delete_conversations_for_repository to remove all conversations associated with the repository, and finally deletes the repository record from the local database using get_sql_session. Handles errors appropriately.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/repositories/business/delete_repository.py",
        "content": "from typing import Iterator\nfrom sqlalchemy.orm import Session\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.github.business.delete_github_repository import delete_github_repository\nfrom app.modassembly.models.repository.Repository import Repository\nfrom app.modassembly.models.user.User import User\nfrom app.modassembly.conversations.business.delete_conversations_for_repository import delete_conversations_for_repository\n\ndef delete_repository(user_id: int, repo_name: str) -> str:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n\n    # Retrieve the user to get the username\n    user: User | None = db.query(User).filter(User.id == user_id).first()\n    if user is None:\n        raise ValueError(f\"User with id {user_id} not found\")\n\n    # Construct the repository full name from username and repo_name\n    full_repo_name: str = f\"{user.username}_{repo_name}\"\n\n    # Retrieve the repository record\n    repo: Repository | None = db.query(Repository).filter(\n        Repository.user_id == user_id,\n        Repository.name == full_repo_name\n    ).first()\n\n    if repo is None:\n        raise ValueError(f\"Repository '{full_repo_name}' not found for user with id {user_id}\")\n\n    # Delete the repository from GitHub\n    # This function will raise an error if the repository does not exist on GitHub.\n    delete_github_repository(user.username, repo_name)\n\n    # Delete all associated conversations for the repository\n    delete_conversations_for_repository(repo.id)\n\n    # Delete the repository record from the local database\n    db.delete(repo)\n    db.commit()\n\n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n\n    return \"Repository deleted successfully\"\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "delete_repository_endpoint",
        "namespace": "app.modassembly.repositories.endpoints",
        "dependencies": [
          "app.modassembly.repositories.business.delete_repository",
          "app.modassembly.auth.authenticate"
        ],
        "purpose": "FastAPI endpoint that receives repository deletion requests, authenticates the request using the authenticate function, validates the payload, and calls delete_repository business logic to remove the repository from both GitHub and the local database. Returns an appropriate HTTP response.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/repositories/endpoints/delete_repository_endpoint.py",
        "content": "from fastapi import APIRouter, Header, HTTPException\nfrom pydantic import BaseModel\nfrom app.modassembly.auth.authenticate import authenticate\nfrom app.modassembly.repositories.business.delete_repository import delete_repository\n\nrouter = APIRouter(\n    prefix=\"/repository\",\n    tags=[\"Repository\"],\n)\n\nclass DeleteRepositoryInput(BaseModel):\n    repo_name: str\n\nclass DeleteRepositoryOutput(BaseModel):\n    message: str\n\n@router.delete(\n    \"\",\n    response_model=DeleteRepositoryOutput,\n    summary=\"Delete Repository\",\n    description=(\n        \"Deletes a repository after authenticating the user using a JWT token. \"\n        \"Requires the repository name in the request payload. The JWT token must be provided \"\n        \"in the 'Authorization' header in the format 'Bearer <token>'.\"\n    ),\n)\ndef delete_repository_endpoint(\n    payload: DeleteRepositoryInput,\n    authorization: str = Header(..., description=\"Bearer token\")\n) -> DeleteRepositoryOutput:\n    \"\"\"\n    Endpoint to delete a repository.\n\n    - **repo_name**: The name of the repository (without the username prefix) to be deleted.\n    \n    The user must supply a valid JWT token in the Authorization header.\n    \"\"\"\n    if not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Invalid authorization header format\")\n    token = authorization[len(\"Bearer \"):].strip()\n\n    user_info = authenticate(token)\n    if \"id\" not in user_info:\n        raise HTTPException(status_code=401, detail=\"Invalid token payload: missing user id\")\n    user_id = user_info[\"id\"]\n\n    message = delete_repository(user_id=user_id, repo_name=payload.repo_name)\n    return DeleteRepositoryOutput(message=message)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "Conversation",
        "namespace": "app.modassembly.models.conversation",
        "dependencies": [
          "app.modassembly.models.repository.Repository",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the conversation."
          },
          {
            "name": "repository_id",
            "purpose": "Foreign key linking the conversation to the repository."
          },
          {
            "name": "conversation_type",
            "purpose": "Type of the conversation (e.g., issue, discussion, chat)."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the conversation was started."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/conversation/Conversation.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey\nfrom app.modassembly.database.sql.get_sql_session import Base\nfrom app.modassembly.models.repository.Repository import Repository\n\nclass Conversation(Base):\n    __tablename__ = \"conversations\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    repository_id = Column(Integer, ForeignKey(Repository.id), nullable=False, index=True)\n    conversation_type = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "datamodel",
        "name": "Message",
        "namespace": "app.modassembly.models.message",
        "dependencies": [
          "app.modassembly.models.conversation.Conversation",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "fields": [
          {
            "name": "id",
            "purpose": "Primary key for the message."
          },
          {
            "name": "conversation_id",
            "purpose": "Foreign key linking the message to its conversation."
          },
          {
            "name": "role",
            "purpose": "Identifies the role of the message sender (e.g., user, admin, system)."
          },
          {
            "name": "content",
            "purpose": "The actual text content of the message."
          },
          {
            "name": "type",
            "purpose": "The type of message (e.g., text, image, code)."
          },
          {
            "name": "created_at",
            "purpose": "Timestamp when the message was created."
          }
        ]
      },
      "file": {
        "path": "app/modassembly/models/message/Message.py",
        "content": "from datetime import datetime\nfrom sqlalchemy import Column, Integer, String, DateTime, ForeignKey\nfrom app.modassembly.database.sql.get_sql_session import Base\nfrom app.modassembly.models.conversation.Conversation import Conversation\n\nclass Message(Base):\n    __tablename__ = \"messages\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    conversation_id = Column(Integer, ForeignKey(Conversation.id), nullable=False, index=True)\n    role = Column(String, nullable=False)\n    content = Column(String, nullable=False)\n    type = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "create_conversations_for_repository",
        "namespace": "app.modassembly.conversations.business",
        "dependencies": [
          "app.modassembly.models.conversation.Conversation",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "For a given repository, creates two default conversations: one for 'brainstorm' and one for 'architecture'. Uses get_sql_session to interact with the database and inserts Conversation records linked to the repository.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/conversations/business/create_conversations_for_repository.py",
        "content": "from typing import Iterator\nfrom sqlalchemy.orm import Session\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.models.conversation.Conversation import Conversation\n\ndef create_conversations_for_repository(repository_id: int) -> None:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    \n    # Create two Conversation instances: one for 'brainstorm' and one for 'architecture'\n    conversation_brainstorm = Conversation(\n        repository_id=repository_id,\n        conversation_type=\"brainstorm\"\n    )\n    conversation_architecture = Conversation(\n        repository_id=repository_id,\n        conversation_type=\"architecture\"\n    )\n    \n    db.add(conversation_brainstorm)\n    db.add(conversation_architecture)\n    db.commit()\n    \n    db.refresh(conversation_brainstorm)\n    db.refresh(conversation_architecture)\n    \n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "delete_conversations_for_repository",
        "namespace": "app.modassembly.conversations.business",
        "dependencies": [
          "app.modassembly.models.conversation.Conversation",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "For a given repository ID, deletes all related Conversation records from the database using get_sql_session.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/conversations/business/delete_conversations_for_repository.py",
        "content": "from typing import Iterator\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.models.conversation.Conversation import Conversation\n\ndef delete_conversations_for_repository(repository_id: int) -> None:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n    \n    db.query(Conversation).filter(Conversation.repository_id == repository_id).delete(synchronize_session=False)\n    db.commit()\n    \n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "get_conversation",
        "namespace": "app.modassembly.conversations.business",
        "dependencies": [
          "app.modassembly.models.conversation.Conversation",
          "app.modassembly.models.repository.Repository",
          "app.modassembly.database.sql.get_sql_session"
        ],
        "purpose": "Retrieves a single conversation related to a given repository, filtered by repository ID, user ID (to validate ownership), and conversation type. It first validates that the repository belongs to the given user by querying the Repository datamodel, then retrieves the conversation from Conversation records using get_sql_session. Returns the matching Conversation record or an error if not found.",
        "pypi_packages": [],
        "is_endpoint": false
      },
      "file": {
        "path": "app/modassembly/conversations/business/get_conversation.py",
        "content": "from typing import Iterator\n\nfrom sqlalchemy.orm import Session\n\nfrom app.modassembly.database.sql.get_sql_session import get_sql_session\nfrom app.modassembly.models.conversation.Conversation import Conversation\nfrom app.modassembly.models.repository.Repository import Repository\n\n\ndef get_conversation(user_id: int, repository_id: int, conversation_type: str) -> Conversation:\n    session_iter: Iterator[Session] = get_sql_session()\n    db: Session = next(session_iter)\n\n    # Validate repository ownership\n    repo: Repository | None = (\n        db.query(Repository)\n        .filter(Repository.id == repository_id, Repository.user_id == user_id)\n        .first()\n    )\n    if repo is None:\n        raise ValueError(f\"Repository with id {repository_id} not found for user {user_id}\")\n\n    conversation: Conversation | None = (\n        db.query(Conversation)\n        .filter(Conversation.repository_id == repository_id, Conversation.conversation_type == conversation_type)\n        .first()\n    )\n    if conversation is None:\n        raise ValueError(\n            f\"Conversation of type '{conversation_type}' for repository {repository_id} not found\"\n        )\n\n    try:\n        next(session_iter)\n    except StopIteration:\n        pass\n\n    return conversation\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "get_conversation_endpoint",
        "namespace": "app.modassembly.conversations.endpoints",
        "dependencies": [
          "app.modassembly.conversations.business.get_conversation",
          "app.modassembly.models.conversation.Conversation",
          "app.modassembly.auth.authenticate"
        ],
        "purpose": "FastAPI endpoint that receives repository ID, user ID, and conversation type as query parameters, authenticates the request using the authenticate function, calls get_conversation to retrieve the matching conversation (while validating repository ownership), and returns an appropriate HTTP response with the conversation details.",
        "pypi_packages": [],
        "is_endpoint": true
      },
      "file": {
        "path": "app/modassembly/conversations/endpoints/get_conversation_endpoint.py",
        "content": "from datetime import datetime\nfrom typing import Any, Dict\n\nfrom fastapi import APIRouter, Header, HTTPException, Query\nfrom pydantic import BaseModel\n\nfrom app.modassembly.auth.authenticate import authenticate\nfrom app.modassembly.conversations.business.get_conversation import get_conversation\nfrom app.modassembly.models.conversation.Conversation import Conversation\n\nrouter = APIRouter(\n    prefix=\"/conversations\",\n    tags=[\"Conversations\"],\n    responses={404: {\"description\": \"Not found\"}},\n)\n\n\nclass GetConversationOutput(BaseModel):\n    id: int\n    repository_id: int\n    conversation_type: str\n    created_at: datetime\n\n    @classmethod\n    def from_orm(cls, conversation: Conversation) -> \"GetConversationOutput\":\n        return cls(\n            id=conversation.id,\n            repository_id=conversation.repository_id,\n            conversation_type=conversation.conversation_type,\n            created_at=conversation.created_at,\n        )\n\n\n@router.get(\n    \"\",\n    response_model=GetConversationOutput,\n    summary=\"Retrieve a Conversation\",\n    description=(\n        \"Retrieves a conversation filtered by repository ID, user ID, and conversation type. \"\n        \"Requires a valid JWT token in the Authorization header (Bearer token). \"\n        \"The token is validated using the authenticate function. On success, returns the conversation details.\"\n    ),\n)\ndef get_conversation_endpoint(\n    repository_id: int = Query(..., description=\"ID of the repository\"),\n    user_id: int = Query(..., description=\"ID of the user owning the repository\"),\n    conversation_type: str = Query(..., description=\"Type of the conversation (e.g., brainstorm, architecture)\"),\n    authorization: str = Header(..., description=\"Bearer token for authentication\"),\n) -> GetConversationOutput:\n    \"\"\"\n    Endpoint to get a conversation associated with a repository for a user.\n    \n    Query Parameters:\n    - **repository_id**: The ID of the repository.\n    - **user_id**: The ID of the user (must match the repository owner).\n    - **conversation_type**: The type of conversation to retrieve.\n    \n    Header:\n    - **Authorization**: A Bearer token for authentication.\n    \n    Returns:\n    - A conversation object with details regarding the conversation.\n    \"\"\"\n    # Extract token from \"Bearer <token>\"\n    if not authorization.startswith(\"Bearer \"):\n        raise HTTPException(status_code=401, detail=\"Invalid authorization header format\")\n    token = authorization.split(\"Bearer \")[1].strip()\n    # Authenticate the token. The returned payload can be used for additional checks if needed.\n    auth_payload: Dict[str, Any] = authenticate(token)\n    \n    # Here you might validate that auth_payload contains the expected user_id if necessary.\n    # For now, we assume that the provided user_id is valid if the token is valid.\n    conversation: Conversation = get_conversation(\n        user_id=user_id,\n        repository_id=repository_id,\n        conversation_type=conversation_type,\n    )\n    return GetConversationOutput.from_orm(conversation)\n"
      },
      "update_status": "up_to_date",
      "is_deployed": false
    },
    {
      "design": {
        "type": "function",
        "name": "authenticate",
        "namespace": "app.modassembly.auth",
        "dependencies": [],
        "purpose": "Verifies the JWT token from the request headers using FastAPI's HTTPBearer (from fastapi.security). The token is validated using a secret key from an environment variable, enabling its use in Swagger UI for interactive API docs. Returns the authenticated user information on success; otherwise, raises an authentication error.",
        "pypi_packages": [
          "pyjwt==2.6.0",
          "fastapi==0.115.6"
        ],
        "is_endpoint": false
      },
      "file": null,
      "update_status": "to_update",
      "is_deployed": false
    }
  ],
  "github": "https://github.com/Modular-Asembly/lgaleana_modassembly-web"
}